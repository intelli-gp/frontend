import { ReceivedUser } from './user';

export type SerializedMessage = {
    MessageID: number;
    RoomID: string;
    User: Pick<ReceivedUser, 'Username' | 'FullName' | 'ProfileImage' | 'ID'>;
    Content: string;
    Type: 'TEXT' | 'IMAGE';
    CreatedAt: string;
    IsDeleted: boolean;
    Reactions?: {
        MessageID: number;
        Reaction: string;
        User: Pick<
            ReceivedUser,
            'Username' | 'FullName' | 'ProfileImage' | 'ID'
        >;
    }[];
    RepliedToMessage?: SerializedMessage;
    IsEdited: boolean;
};

export type AIMessageType = {
    MessageID: number;
    /**
     * If the message was generated by the AI
     * else it was sent by a user
     */
    AIGenerated: boolean;
    Content: string;
    CreatedAt: string;
};

export type CreateMessageDTO = {
    RepliedToMessageID?: number;
    Content: string;
    Type: 'TEXT' | 'IMAGE';
    GroupID: number;
};

export type UpdateMessageDTO = {
    Content: string;
    MessageID: number;
};

export type DeleteMessageDTO = {
    MessageID: number;
};

export type ReceivedTypingDTO = {
    IsTyping: boolean;
    Username: string;
    FullName: string;
};

export type MessageInfo = {
    MessageID: number;
    UserID: number;
    Username: string;
    FullName: string;
    ProfileImage: string;
    ReadAt: string; // Date
};

export type ReactToMessageDTO = {
    MessageID: number;
    Reaction: string;
};

export type SendIsTypingDTO = { IsTyping: boolean; GroupID: number };

export type ClientToServerEvents = {
    createMessage: (
        data: CreateMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    joinRoom: (
        data: { ChatGroupId: number },
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    leaveRoom: (
        data: { ChatGroupId: number },
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    typing: (
        data: SendIsTypingDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    deleteMessage: (
        data: DeleteMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    editMessage: (
        data: UpdateMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    getMessageInfo: (
        data: DeleteMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    leaveMessageInfoRoom: (
        data: DeleteMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    reactToMessage: (
        data: ReactToMessageDTO,
        feedback: (error: SocketCustomError) => Promise<void>,
    ) => void;
    refreshToken: (data: { accessToken: string }) => void;
};

type EmitTypes = Parameters<
    ClientToServerEvents[keyof ClientToServerEvents]
>[0];

export type ServerToClientEvents = {
    isTyping: (data: ReceivedTypingDTO) => void;
    newMessage: (message: SerializedMessage) => void;
    allMessages: (messages: SerializedMessage[]) => void;
    editedMessage: (message: SerializedMessage) => void;
    error: (data: any) => void; // TODO: fix this
    messageInfo: (data: any) => void; // TODO: fix this
    newMessageReadInfo: (data: any) => void; // TODO: fix this
    userStatus: (data: {
        username: string;
        status: 'online' | 'offline';
    }) => void;
    tokenRefreshed: (data: string) => void;
};

export type SocketCustomError = {
    error?: string;
    message?: string;
};
